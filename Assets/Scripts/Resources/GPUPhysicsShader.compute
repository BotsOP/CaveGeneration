#pragma kernel MeshOverlapSphere
#pragma kernel MeshIntersectRay

struct Vertex
{
	float3 position;
	float3 normal;
};

RWStructuredBuffer<Vertex> vertexBuffer;
RWStructuredBuffer<uint> indexBuffer;
float4 circle;
RWStructuredBuffer<int> output;

bool SphereTriangleCollision(float3 sphereCenter, float sphereRadius, float3 p0, float3 p1, float3 p2)
{
	if(distance(sphereCenter, p0) < sphereRadius)
	{
		return true;
	}
	if(distance(sphereCenter, p1) < sphereRadius)
	{
		return true;
	}
	if(distance(sphereCenter, p2) < sphereRadius)
	{
		return true;
	}
	// Calculate the triangle's plane normal
	float3 N = normalize(cross(p1 - p0, p2 - p0));

	// Calculate the signed distance between the sphere's center and the plane
	float dist = dot(sphereCenter - p0, N);

	// Check if the sphere intersects the plane
	if (dist < -sphereRadius || dist > sphereRadius)
		return false;

	// Project the sphere's center onto the triangle's plane
	float3 point0 = sphereCenter - N * dist;

	// Determine if the projected point is inside the triangle
	float3 c0 = cross(point0 - p0, p1 - p0);
	float3 c1 = cross(point0 - p1, p2 - p1);
	float3 c2 = cross(point0 - p2, p0 - p2);
	bool inside = dot(c0, N) <= 0 && dot(c1, N) <= 0 && dot(c2, N) <= 0;

	return inside;
}

[numthreads(512,1,1)]
void MeshOverlapSphere (uint id : SV_DispatchThreadID)
{
	float3 pos0 = vertexBuffer[indexBuffer[id * 3 + 0]].position;
	float3 pos1 = vertexBuffer[indexBuffer[id * 3 + 1]].position;
	float3 pos2 = vertexBuffer[indexBuffer[id * 3 + 2]].position;
	if(SphereTriangleCollision(circle.xyz, circle.w, pos0, pos1, pos2))
	{
		InterlockedAdd(output[0], 1);
	}
}

float3 rayOrigin;
float3 rayDirection;
RWStructuredBuffer<int> countBuffer;
AppendStructuredBuffer<float4> intersectBuffer;

bool RayTriangleIntersect(float3 V0, float3 V1, float3 V2, out float Distance)
{
	float3 E1 = V1 - V0;
	float3 E2 = V2 - V0;
	float3 P = cross(rayDirection, E2);
	float Det = dot(E1, P);
	
	if (Det > -0.000001f && Det < 0.000001f)
		return false;
	
	float3 T = rayOrigin - V0;
	float U = dot(T, P) / Det;
	
	if (U < 0.0f || U > 1.0f)
		return false;
	
	float3 Q = cross(T, E1);
	float V = dot(rayDirection, Q) / Det;
	
	if (V < 0.0f || U + V > 1.0f)
		return false;
	
	Distance = dot(E2, Q) / Det;
	return true;
}

[numthreads(512,1,1)]
void MeshIntersectRay (uint id : SV_DispatchThreadID)
{
	float3 pos0 = vertexBuffer[indexBuffer[id * 3 + 0]].position;
	float3 pos1 = vertexBuffer[indexBuffer[id * 3 + 1]].position;
	float3 pos2 = vertexBuffer[indexBuffer[id * 3 + 2]].position;

	float t;
	if(RayTriangleIntersect(pos0, pos1, pos2, t))
	{
		InterlockedAdd(countBuffer[0], 1);
		intersectBuffer.Append(float4(rayOrigin + rayDirection * t, id));
	}
	
}
